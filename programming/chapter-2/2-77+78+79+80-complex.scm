; 2.77 - this works becuase we:
;   1 - call magnitude globally
;   2 - get the tag as complex, and pass the contents to the registered magnitude call for complex numbers
;   3 - call magnitude globally again
;   4 - get the tag as (real or polar), and pass the contents on to the magnitude call registered for real or polar numbers

(define *op-table* (make-hash-table))
(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))
(define (get op type)
  (hash-table/get *op-table* (list op type) #f))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
	      (apply proc (map contents args))
	      (error "No method for these types -- APPLY-GENERIC" (list op type-tags))))))

(define (attach-tag tag data)
  (if (number? data)
    data
    (cons tag data)))
(define (type-tag number)
  (if (number? number)
    'scheme-number
    (car number)))
(define (contents number)
  (if (number? number)
    number
    (cdr number)))

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) =)
  (put '=zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)

(define (install-rational-package)
  (define (gcd x y)
    (if (= y 0)
         x
         (gcd y (modulo x y))))
  (define (make-rat num den)
    (let ((g (gcd num den)))
        (cons
            (/ num g)
            (/ den g))))
  (define numer car)
  (define denom cdr)
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
	      (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
	      (* (numer y) (denom x))))
  (define (equ? x y)
    (and (= (numer x) (numer y))
	 (= (denom x) (denom y))))
  (define (=zero? n) (= 0 (numer n)))
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'equ? '(rational rational) equ?)
  (put '=zero? '(rational) =zero?)
  'done)

(define (install-rectangular-package)
  (define make-from-real-imag cons)
  (define (make-from-mag-ang m a)
    (make-from-real-imag (* r (cos a)) (* r (sin a))))
  (define real-part car)
  (define imag-part cdr)
  (define (magnitude x)
    (sqrt (+ (square (real-part x))
	     (square (imag-part x)))))
  (define (angle x)
    (atan (imag-part x) (real-part x)))
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (x y) (tag (make-from-mag-ang m a))))
  'done)

(define (install-polar-package)
  (define make-from-mag-ang cons)
  (define (make-from-real-imag x y)
    (make-from-mag-ang
     (sqrt (+ (square x) (square y)))
     (atan y x)))
  (define magnitude car)
  (define angle cdr)
  (define (real-part x)
    (* (magnitude x) (cos (angle x))))
  (define (imag-part x)
    (* (magnitude x) (sin (angle x))))
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (m a) (tag (make-from-mag-ang m a))))
  'done)

(define (install-complex-package)
  (install-rectangular-package)
  (install-polar-package)
  (define make-from-real-imag
    (get 'make-from-real-imag 'rectangular))
  (define make-from-mag-ang
    (get 'make-from-mag-ang 'polar))
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
			                   (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
			                   (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
		                   (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
		                   (- (angle z1) (angle z2))))
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (m a) (tag (make-from-mag-ang m a))))
  'done)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(let ((n1 (make-scheme-number 10))
      (n2 (make-scheme-number 5))
      (n3 (make-scheme-number 5))
      (n4 (make-scheme-number 0)))
  (display n1)(newline)
  (display n2)(newline)
  (display (add n1 n2))(newline)
  (display (sub n1 n2))(newline)
  (display (mul n1 n2))(newline)
  (display (div n1 n2))(newline)
  (display (equ? n1 n2))(newline)
  (display (equ? n2 n3))(newline)
  (display (=zero? n3))(newline)
  (display (=zero? n4))(newline)(newline))
(let ((r1 (make-rational 1 2))
      (r2 (make-rational 2 3))
      (r3 (make-rational 2 4))
      (r4 (make-rational 0 1)))
  (display (add r1 r2))(newline)
  (display (sub r1 r2))(newline)
  (display (mul r1 r2))(newline)
  (display (div r1 r2))(newline)
  (display (equ? r1 r2))(newline)
  (display (equ? r1 r3))(newline)
  (display (=zero? r3))(newline)
  (display (=zero? r4))(newline)(newline))

(let ((c1 (make-complex-from-real-imag 1 2))
      (c2 (make-complex-from-real-imag 2 3))
      (c3 (make-complex-from-mag-ang 5 0.7)))
  (display (add c1 c2))(newline)
  (display (add c1 c3))(newline)
  (display c1)(newline)
  (display c2)(newline)
  (display c3)(newline)
  (display (magnitude c3))(newline))
