(define *op-table* (make-hash-table))
(define (put op type proc) (hash-table/put! *op-table* (list op type) proc))
(define (get op type) (hash-table/get *op-table* (list op type) '()))

(define (attach-tag tag data) (cons tag data))
(define (type-tag number) (car number))
(define (contents number) (cdr number))

(define (install-integer-package)
  (define (tag x) (attach-tag 'integer x))
  (define (raise x) (make-rational x 1))
  (put 'add '(integer integer)
       (lambda (x y) (tag (+ x y))))
  (put 'make 'integer
       (lambda (x) (tag x)))
  (put 'raise 'integer raise)
  'done)

(define (install-rational-package)
  (define (gcd x y)
    (if (= y 0)
         x
         (gcd y (modulo x y))))
  (define (make-rat num den)
    (let ((g (gcd num den)))
        (cons
            (/ num g)
            (/ den g))))
  (define numer car)
  (define denom cdr)
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		             (* (numer y) (denom x)))
	            (* (denom x) (denom y))))
  (define (raise x) (make-real-number (/ (* 1.0 (numer x)) (denom x))))
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'raise 'rational raise)
  'done)

(define (install-real-number-package)
  (define (raise x) (make-complex-from-real-imag x 0))
  (define (tag x) (attach-tag 'real-number x))
  (put 'add '(real-number real-number)
       (lambda (x y) (tag (+ x y))))
  (put 'make 'real-number
       (lambda (x) (tag x)))
  (put 'raise 'real-number raise)
  'done)

(define (install-rectangular-package)
  (define real-part car)
  (define imag-part cdr)
  (define make-from-real-imag cons)
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part 'rectangular real-part)
  (put 'imag-part 'rectangular imag-part)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  'done)

(define (install-complex-package)
  (install-rectangular-package)
  (define (real-part x) ((get 'real-part (type-tag x)) (contents x)))
  (define (imag-part x) ((get 'imag-part (type-tag x)) (contents x)))
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
			                   (+ (imag-part z1) (imag-part z2))))
  (define make-from-real-imag
    (get 'make-from-real-imag 'rectangular))
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  'done)

(install-integer-package)
(install-rational-package)
(install-real-number-package)
(install-complex-package)
(define (make-integer n)
  ((get 'make 'integer) n))
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (make-real-number n)
  ((get 'make 'real-number) n))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))

(define (raise-to type n)
  (let ((cur-type (type-tag n)))
    (if (eq? cur-type type)
        n
        (let ((raise-fn (get 'raise cur-type)))
          (if (null? raise-fn)
              '()
              (raise-to type (raise-fn (contents n))))))))

(define (apply-generic op arg1 arg2)
  (let ((type1 (type-tag arg1))
        (type2 (type-tag arg2)))
    (let ((proc (get op (list type1 type2))))
      (if (not (null? proc))
          (proc (contents arg1) (contents arg2))
          (if (eq? type1 type2)
            (error "No method found for these types" (list op type1 type2))
            (let ((arg1b (raise-to type2 arg1))
                  (arg2b (raise-to type1 arg2))
                  (proc1 (get op (list type1 type1)))
                  (proc2 (get op (list type2 type2))))
              (cond ((and (not (null? arg2b))
                          (not (null? proc1)))
                      (proc1 (contents arg1) (contents arg2b)))
                    ((and (not (null? arg1b))
                          (not (null? proc2)))
                      (proc2 (contents arg1b) (contents arg2)))
                    (else (error "No method for these types" (list op type1 type2))))))))))

(define (add x y) (apply-generic 'add x y))

(let* ((integer1 (make-integer 2))
       (rational1 (raise-to 'rational integer1))
       (real1 (raise-to 'real-number integer1))
       (complex1 (raise-to 'complex integer1))
       (r2 (raise-to 'rational complex1)))
  (display integer1)(newline)
  (display rational1)(newline)
  (display real1)(newline)
  (display complex1)(newline)
  (display (add integer1 integer1))(newline)
  (display (add rational1 rational1))(newline)
  (display (add real1 real1))(newline)
  (display (add complex1 complex1))(newline)
  (display (add integer1 complex1))(newline)
  (display (add rational1 integer1))(newline)
  (display r2)(newline))