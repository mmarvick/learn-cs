(define *op-table* (make-hash-table))
(define (put op type proc) (hash-table/put! *op-table* (list op type) proc))
(define (get op type) (hash-table/get *op-table* (list op type) '()))

(define (attach-tag tag data)
  (if (number? data)
    data
    (cons tag data)))
(define (type-tag number)
  (if (number? number)
    'scheme-number
    (car number)))
(define (contents number)
  (if (number? number)
    number
    (cdr number)))

(define (apply-generic-one-arg op arg)
  (let* ((type (type-tag arg))
         (proc (get op (list type))))
    (if (not (null? proc))
      (proc (contents arg))
      (error "No method found for type" (list op type)))))

(define (apply-generic op arg1 arg2)
  (let ((type1 (type-tag arg1))
        (type2 (type-tag arg2)))
    (let ((proc (get op (list type1 type2))))
      (if (not (null? proc))
          (proc (contents arg1) (contents arg2))
          (if (eq? type1 type2)
            (error "No method found for these types" (list op type1 type2))
            (let ((arg1b (raise-to type2 arg1))
                  (arg2b (raise-to type1 arg2))
                  (proc1 (get op (list type1 type1)))
                  (proc2 (get op (list type2 type2))))
              (cond ((and (not (null? arg2b))
                          (not (null? proc1)))
                      (proc1 (contents arg1) (contents arg2b)))
                    ((and (not (null? arg1b))
                          (not (null? proc2)))
                      (proc2 (contents arg1b) (contents arg2)))
                    (else (error "No method for these types" (list op type1 type2))))))))))

(define (install-rational-package)
  (define (gcd x y)
    (if (= y 0)
         x
         (gcd y (modulo x y))))
  (define (make-rat num den)
    (let ((g (gcd num den)))
        (cons
            (/ num g)
            (/ den g))))
  (define numer car)
  (define denom cdr)
  (define (negate-rat x)
    (make-rat (* -1 (numer x))
              (denom x)))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		             (* (numer y) (denom x)))
	            (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
	      (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
	      (* (numer y) (denom x))))
  (define (equ? x y)
    (and (= (numer x) (numer y))
	       (= (denom x) (denom y))))
  (define (=zero? n) (= 0 (numer n)))
  (define (raise x) (make-scheme-number (/ (* 1.0 (numer x)) (denom x))))
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'equ? '(rational rational) equ?)
  (put '=zero? '(rational) =zero?)
  (put 'negate '(rational) 
       (lambda (x) (tag (negate-rat x))))
  (put 'raise 'rational raise)
  'done)

(define (install-scheme-number-package)
  (define (raise x) (make-complex-from-real-imag x 0))
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) =)
  (put '=zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'negate '(scheme-number)
       (lambda (x) (* -1 x)))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'raise 'scheme-number raise)
  'done)

(define (install-rectangular-package)
  (define real-part car)
  (define imag-part cdr)
  (define make-from-real-imag cons)
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part 'rectangular real-part)
  (put 'imag-part 'rectangular imag-part)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  'done)

(define (install-complex-package)
  (install-rectangular-package)
  (define (real-part x) ((get 'real-part (type-tag x)) (contents x)))
  (define (imag-part x) ((get 'imag-part (type-tag x)) (contents x)))
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
			                   (+ (imag-part z1) (imag-part z2))))
  (define make-from-real-imag
    (get 'make-from-real-imag 'rectangular))
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  'done)

(define (install-polynomial-package)
  ;; construct / select from the polynomial
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  ;; construct / modify / select from the term list
  (define (empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))

  ;; construct / select from the individual terms
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; operations
  (define (=zero-poly? p)
    (empty-termlist? (term-list p)))
  (define variable? symbol?)
  (define (same-variable? v1 v2)
    (and (variable? v1)
         (variable? v2)
         (eq? v1 v2)))
  (define (negate-poly p)
    (make-poly (variable p)
               (negate-terms (term-list p))))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var - ADD-POLY" (list p1 p2))))
  (define (sub-poly p1 p2)
    (add-poly p1 (negate-poly p2)))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
            (let ((t1 (first-term L1))
                  (t2 (first-term L2)))
              (let ((o1 (order t1))
                    (o2 (order t2)))
                (cond ((> o1 o2)
                        (adjoin-term
                          t1 (add-terms (rest-terms L1) L2)))
                      ((< o1 o2)
                        (adjoin-term
                          t2 (add-terms L1 (rest-terms L2))))
                      (else
                        (adjoin-term
                          (make-term o1
                                     (add (coeff t1) (coeff t2)))
                          (add-terms (rest-terms L1)
                                     (rest-terms L2))))))))))
  (define (negate-terms L1)
    (if (empty-termlist? L1)
        L1
        (let ((t1 (first-term L1)))
          (adjoin-term
            (make-term (order t1) (negate (coeff t1)))
            (negate-terms (rest-terms L1))))))

  ;; define public interface
  (define (tag z) (attach-tag 'polynomial z))
  (put 'add '(polynomial polynomial)
       (lambda (x y) (tag (add-poly x y))))
  (put 'sub '(polynomial polynomial)
       (lambda (x y) (tag (sub-poly x y))))
  (put 'mul '(polynomial polynomial)
       (lambda (x y) (tag (mul-poly x y))))
  (put '=zero? '(polynomial) =zero-poly?)
  (put 'negate '(polynomial)
       (lambda (x) (tag (negate-poly x))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  (put 'make-term 'polynomial make-term))

(install-rational-package)
(install-scheme-number-package)
(install-complex-package)
(install-polynomial-package)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-polynomial variable term-list)
  ((get 'make 'polynomial) variable term-list))
(define (make-polynomial-term order coeff)
  ((get 'make-term 'polynomial) order coeff))

(define (raise-to type n)
  (let ((cur-type (type-tag n)))
    (if (eq? cur-type type)
        n
        (let ((raise-fn (get 'raise cur-type)))
          (if (null? raise-fn)
              '()
              (raise-to type (raise-fn (contents n))))))))

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic-one-arg '=zero? x))
(define (negate x) (apply-generic-one-arg 'negate x))
(define (real-part z) (apply-generic-one-arg 'real-part z))
(define (imag-part z) (apply-generic-one-arg 'imag-part z))
(define (magnitude z) (apply-generic-one-arg 'magnitude z))
(define (angle z) (apply-generic-one-arg 'angle z))

(let* ((p1 (make-polynomial
            'x
            (list (make-polynomial-term 2 1)
                  (make-polynomial-term 1 4)
                  (make-polynomial-term 0 5))))
      (p2 (make-polynomial
            'x
            (list (make-polynomial-term 3 3)
                  (make-polynomial-term 1 (make-rational 4 3))
                  (make-polynomial-term 0 7))))
      (p3 (make-polynomial
            'y
            (list (make-polynomial-term 3 4))))
      (p4 (make-polynomial
            'x
            '()))
  (display p1)(newline)
  (display p2)(newline)
  (display p3)(newline)
  (display p4)(newline)
  (display (=zero? p1))(newline)
  (display (=zero? p4))(newline)
  (display (add p1 p2))(newline)
  (display (sub p1 p2))(newline)
  ; (display (mul p1 p2))(newline)
)