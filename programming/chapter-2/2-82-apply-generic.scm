; this strategy relies on either:
;   - finding the operation for the given tags as input (e.g. t1 t2 t4)
;   - mapping all the tags to one or the other's type, and then applying the op (e.g. all to t1, t2, or t4, then operate)
; this wouldn't work in the case where:
;   - you can't convert them all to eachother, but could convert them all to t3 and then apply the op
;   - the op may not be defined for args all of one type, but would for say (t1 t1 t4), although this case seems less likely


(define *op-table* (make-hash-table))
(define *coercion-table* (make-hash-table))
(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))
(define (get op type)
  (hash-table/get *op-table* (list op type) #f))
(define (put-coercion type1 type2 coercion)
  (hash-table/put! *coercion-table* (list type1 type2) coercion))
(define (get-coercion type1 type2)
  (hash-table/get *coercion-table* (list type1 type2) #f))

(define (accumulate op init seq)
    (if (null? seq) init
                    (op (car seq) (accumulate op init (cdr seq)))))

(define (flatmap op seq)
  (accumulate append '() (map op seq)))

(define (attach-tag tag data)
  (if (number? data)
    data
    (cons tag data)))
(define (type-tag number)
  (if (number? number)
    'scheme-number
    (car number)))
(define (contents number)
  (if (number? number)
    number
    (cdr number)))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) =)
  (put '=zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)

(define (install-rational-package)
  (define (gcd x y)
    (if (= y 0)
         x
         (gcd y (modulo x y))))
  (define (make-rat num den)
    (let ((g (gcd num den)))
        (cons
            (/ num g)
            (/ den g))))
  (define numer car)
  (define denom cdr)
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
	      (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
	      (* (numer y) (denom x))))
  (define (equ? x y)
    (and (= (numer x) (numer y))
	 (= (denom x) (denom y))))
  (define (=zero? n) (= 0 (numer n)))
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'equ? '(rational rational) equ?)
  (put '=zero? '(rational) =zero?)
  'done)

(define (install-rectangular-package)
  (define make-from-real-imag cons)
  (define (make-from-mag-ang m a)
    (make-from-real-imag (* r (cos a)) (* r (sin a))))
  (define real-part car)
  (define imag-part cdr)
  (define (magnitude x)
    (sqrt (+ (square (real-part x))
	     (square (imag-part x)))))
  (define (angle x)
    (atan (imag-part x) (real-part x)))
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (x y) (tag (make-from-mag-ang m a))))
  'done)

(define (install-polar-package)
  (define make-from-mag-ang cons)
  (define (make-from-real-imag x y)
    (make-from-mag-ang
     (sqrt (+ (square x) (square y)))
     (atan y x)))
  (define magnitude car)
  (define angle cdr)
  (define (real-part x)
    (* (magnitude x) (cos (angle x))))
  (define (imag-part x)
    (* (magnitude x) (sin (angle x))))
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (m a) (tag (make-from-mag-ang m a))))
  'done)

(define (install-complex-package)
  (install-rectangular-package)
  (install-polar-package)
  (define make-from-real-imag
    (get 'make-from-real-imag 'rectangular))
  (define make-from-mag-ang
    (get 'make-from-mag-ang 'polar))
  (define (real-part x) (apply-generic 'real-part x))
  (define (imag-part x) (apply-generic 'imag-part x))
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
			                   (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
			                   (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
		                   (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
		                   (- (angle z1) (angle z2))))
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (m a) (tag (make-from-mag-ang m a))))
  'done)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
(put-coercion 'scheme-number 'rational
  (lambda (num) (make-rational num 1)))

(define (coerce-ops type-tags)
  (define (coerce-op type1 type2)
    (if (eq? type1 type2)
        (lambda (x) x)
        (hash-table/get *coercion-table* (list type1 type2) '())))
  (define (coerce-iter type-tags type-targets)
    (if (null? type-targets)
        '()
        (let* ((type-target (car type-targets))
               (coercions
                (flatmap
                  (lambda (type-tag)
                    (let ((coercion-op (coerce-op type-tag type-target)))
                      (if (null? coercion-op)
                          '()
                          (list coercion-op))))
                  type-tags)))
          (if (= (length type-tags) (length coercions))
              coercions
              (coerce-iter type-tags (cdr type-targets))))))
  (coerce-iter type-tags type-tags))

(define (coerce-list args coercions)
  (if (null? args)
      '()
      (cons
        ((car coercions) (car args))
        (coerce-list (cdr args) (cdr coercions)))))

(define (apply-generic op . args)
  (define (same-types? type-tags)
    (if (or (null? type-tags) (null? (cdr type-tags)))
        #t
        (and
          (eq? (car type-tags) (cadr type-tags))
          (same-types? (cdr type-tags)))))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (same-types? type-tags)
            (error "No method found for these types" (list op type-tags))
            (let ((coercion-ops (coerce-ops type-tags)))
              (if (null? coercion-ops)
                  (error "No method for these types" (list op type-tags))
                  (let ((coerced-args (coerce-list args coercion-ops)))
                    (apply apply-generic op coerced-args)))))))))

(let ((n1 (make-scheme-number 10))
      (n2 (make-scheme-number 20))
      (n3 (make-scheme-number 30))
      (r1 (make-rational 1 2))
      (r2 (make-rational 1 3))
      (c1 (make-complex-from-real-imag 1 2)))
    (display (apply-generic 'add n1 n2))(newline)
    (display (apply-generic 'add n1 n3))(newline)
    (display (apply-generic 'add n1 r1))(newline)
    (display (apply-generic 'add r1 n1))(newline)
    (display (apply-generic 'add c1 c1))(newline)
    (display (apply-generic 'add n1 c1))(newline))
